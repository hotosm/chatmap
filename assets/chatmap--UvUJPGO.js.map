{"version":3,"file":"chatmap--UvUJPGO.js","sources":["../../src/parsers/chatmap.js"],"sourcesContent":["/*\n * This will be used for all parsers for extracting related messages\n * ex: location + media from chats.\n*/\n\n/**\n * Get closest message (in terms time) from the same user.\n * It will scan a dictionary of messages, starting in msgIndex position.\n * From that position, it will look for messages of the same user in both\n * directions (previous and next), calculate time dalta and return the\n * closest one.\n * @param {object} messages Dictionary of messages ex: messages[msgIndex]\n * @param {int} msgIndex A message index\n * @returns {object} message\n */\nexport const getClosestMessage = (messages, msgIndex) => {\n    // Previous message index\n    let prevIndex = msgIndex - 1;\n    // Next message index\n    let nextIndex = msgIndex + 1;\n    // Previous message\n    let prevMessage;\n    // Next message\n    let nextMessage;\n    // Closest message\n    let message = messages[msgIndex];\n\n    while (\n\n      // There's a prev or next message\n      // but no next or prev messages has been initialited\n      (messages[prevIndex] || messages[nextIndex]) && \n      !(nextMessage && prevMessage) ) {\n\n      // If PREV message is from the same user\n      if (messages[prevIndex] &&\n          // Message from the same user than previous one\n          messages[prevIndex].username === message.username &&\n         !prevMessage) {\n        // Calculate time passed between current and previous message.\n        const delta_prev = Math.abs(messages[msgIndex].time - messages[prevIndex].time);\n        prevMessage = {\n            index: prevIndex, \n            delta: delta_prev\n        }\n      }\n\n      // If NEXT message is from the same user\n      if (messages[nextIndex] && \n          // Message from the same user than next one\n          messages[nextIndex].username === message.username &&\n          !nextMessage) {\n        // Calculate time passed between current and next message.\n        const delta_next = Math.abs(messages[msgIndex].time - messages[nextIndex].time);\n        nextMessage = {\n            index: nextIndex, \n            delta: delta_next\n        }\n      }\n\n      prevIndex--;\n      nextIndex++;\n    }\n\n    // If there are prev and next messages\n    // check the time difference between the two\n    // to decide which to return\n\n    if (prevMessage && nextMessage) {\n\n      if (prevMessage.delta === nextMessage.delta) {\n        return {\n            ...messages[prevMessage.index],\n            message: messages[prevMessage.index].message + \". \" + messages[nextMessage.index].message\n        }\n      } else if (prevMessage.delta < nextMessage.delta) {\n        return messages[prevMessage.index];\n      } else if (prevMessage.delta > nextMessage.delta) {\n        return messages[nextMessage.index];\n      }\n\n    } else if (prevMessage) {\n      return messages[prevMessage.index];\n    } else if (nextMessage) {\n      return messages[nextMessage.index];\n    }\n    return message;\n}\n\n// Get closest next message from the same user\nexport const getClosestNextMessage = (messages, msgIndex) => {\n    return getClosestMessageByDirection(messages, msgIndex, 1);\n}\n\n// Get closest previous message from the same user\nexport  const getClosestPrevMessage = (messages, msgIndex) => {\n    return getClosestMessageByDirection(messages, msgIndex, -1);\n}\n\n// Get closest next/prev message from the same user\nexport  const getClosestMessageByDirection = (messages, msgIndex, direction) => {\n    let nextIndex = msgIndex + direction;\n    let nextMessage;\n    let message = messages[msgIndex];\n    while (\n      (messages[nextIndex]) && !(nextMessage) ) {\n    \n      if (messages[nextIndex] && \n          messages[nextIndex].username === message.username &&\n          !nextMessage) {\n        const delta_next = Math.abs(messages[msgIndex].time - messages[nextIndex].time);\n        nextMessage = {\n            index: nextIndex, \n            delta: delta_next\n        }\n      }\n      nextIndex += direction;\n    }\n    if (nextMessage) {\n      return messages[nextMessage.index];\n    }\n    return message;\n}\n"],"names":["getClosestMessage","messages","msgIndex","prevIndex","nextIndex","prevMessage","nextMessage","message","delta_prev","delta_next","getClosestNextMessage","getClosestMessageByDirection","getClosestPrevMessage","direction"],"mappings":"AAeY,MAACA,EAAoB,CAACC,EAAUC,IAAa,CAErD,IAAIC,EAAYD,EAAW,EAEvBE,EAAYF,EAAW,EAEvBG,EAEAC,EAEAC,EAAUN,EAASC,CAAQ,EAE/B,MAIGD,EAASE,CAAS,GAAKF,EAASG,CAAS,IAC1C,EAAEE,GAAeD,IAAe,CAGhC,GAAIJ,EAASE,CAAS,GAElBF,EAASE,CAAS,EAAE,WAAaI,EAAQ,UAC1C,CAACF,EAAa,CAEf,MAAMG,EAAa,KAAK,IAAIP,EAASC,CAAQ,EAAE,KAAOD,EAASE,CAAS,EAAE,IAAI,EAC9EE,EAAc,CACV,MAAOF,EACP,MAAOK,CACnB,CACA,CAGM,GAAIP,EAASG,CAAS,GAElBH,EAASG,CAAS,EAAE,WAAaG,EAAQ,UACzC,CAACD,EAAa,CAEhB,MAAMG,EAAa,KAAK,IAAIR,EAASC,CAAQ,EAAE,KAAOD,EAASG,CAAS,EAAE,IAAI,EAC9EE,EAAc,CACV,MAAOF,EACP,MAAOK,CACnB,CACA,CAEMN,IACAC,GACN,CAMI,GAAIC,GAAeC,EAAa,CAE9B,GAAID,EAAY,QAAUC,EAAY,MACpC,MAAO,CACH,GAAGL,EAASI,EAAY,KAAK,EAC7B,QAASJ,EAASI,EAAY,KAAK,EAAE,QAAU,KAAOJ,EAASK,EAAY,KAAK,EAAE,OAC9F,EACa,GAAID,EAAY,MAAQC,EAAY,MACzC,OAAOL,EAASI,EAAY,KAAK,EAC5B,GAAIA,EAAY,MAAQC,EAAY,MACzC,OAAOL,EAASK,EAAY,KAAK,CAGpC,KAAM,IAAID,EACT,OAAOJ,EAASI,EAAY,KAAK,EAC5B,GAAIC,EACT,OAAOL,EAASK,EAAY,KAAK,EAEnC,OAAOC,CACX,EAGaG,EAAwB,CAACT,EAAUC,IACrCS,EAA6BV,EAAUC,EAAU,CAAC,EAI/CU,EAAwB,CAACX,EAAUC,IACtCS,EAA6BV,EAAUC,EAAU,EAAE,EAIhDS,EAA+B,CAACV,EAAUC,EAAUW,IAAc,CAC5E,IAAIT,EAAYF,EAAWW,EACvBP,EACAC,EAAUN,EAASC,CAAQ,EAC/B,KACGD,EAASG,CAAS,GAAM,CAAEE,GAAe,CAE1C,GAAIL,EAASG,CAAS,GAClBH,EAASG,CAAS,EAAE,WAAaG,EAAQ,UACzC,CAACD,EAAa,CAChB,MAAMG,EAAa,KAAK,IAAIR,EAASC,CAAQ,EAAE,KAAOD,EAASG,CAAS,EAAE,IAAI,EAC9EE,EAAc,CACV,MAAOF,EACP,MAAOK,CACnB,CACA,CACML,GAAaS,CACnB,CACI,OAAIP,EACKL,EAASK,EAAY,KAAK,EAE5BC,CACX"}