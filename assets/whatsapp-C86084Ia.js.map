{"version":3,"file":"whatsapp-C86084Ia.js","sources":["../../src/parsers/whatsapp.js"],"sourcesContent":["\n/**\n * Contains a main parser function and supporting fuctions\n * for creating a map from a WhatsApp conversation log.\n *\n * The Map is stored in memory as a GeoJSON and a list\n * of media files\n */\n\nimport { getClosestMessage, getClosestNextMessage, getClosestPrevMessage } from \"./chatmap\";\n\n// Regex to search for coordinates in the format <lat>,<lon> (ex: -31.006037,-64.262794)\nconst LOCATION_PATTERN = /[-+]?([1-8]?\\d(\\.\\d+)?|90(\\.0+)?),\\s*[-+]?(180(\\.0+)?|((1[0-7]\\d)|([1-9]?\\d))(\\.\\d+)?).*$/;\n\n// Regex to search for messages in the format [<date>, <time>] <username>: <message>\nconst MSG_PATTERN = {\n    IOS: /\\[(.*)\\] ([^:]*): (.*)/,\n    ANDROID: /(.*) - ([^:]*): (.*)/\n}\n\n// Detect system (Android or iOS)\nexport const detectSystem = (line) => {\n    const match_ios = line.match(MSG_PATTERN.IOS);\n    const match_android = line.match(MSG_PATTERN.ANDROID);\n    if (match_ios) {\n        return \"IOS\";\n    } else if (match_android) {\n        return \"ANDROID\"\n    }\n    return \"UNKNOWN\";\n}\n\n// Look for jpg or mp4 media files\nexport const lookForMediaFile = (msgObject) => {\n    const msg = msgObject.message.toLowerCase();\n    let mediaFileIndex = msg.indexOf(\".jpg\");\n    if (mediaFileIndex < 0) {\n        mediaFileIndex = msg.indexOf(\".mp4\");\n    }\n    if (mediaFileIndex > 0) {\n        let path = msgObject.message.substring(msg.lastIndexOf(\":\") + 1, mediaFileIndex + 4);\n        if (path.substring(0, 1) == \" \") {\n            return path.substring(1, path.length)\n        }\n        return path;\n    }\n    return \"\"\n}\n\n// Search for a location\nexport const searchLocation = (line) => {\n    const match = line.match(LOCATION_PATTERN);\n    if (match) {\n        return match[0].split(\",\").map(x => parseFloat(x))\n    }\n    return null;\n}\n\n// Parse time, username and message\nexport const parseMessage = (line, system) => {\n    const match = line.match(MSG_PATTERN[system]);\n    if (match) {\n        let username = match[2];\n\n        // Check if the username has a ':' character and remove the text after it\n        const usernameIndexOf = username.indexOf(\":\");\n        if (usernameIndexOf > -1) {\n            username = username.substring(0, usernameIndexOf);\n        }\n\n        let msgObject = {\n            time: parseTimeString(match[1]),\n            username:  username,\n            message: match[3],\n        }\n\n        // Look for media\n        msgObject.file = lookForMediaFile(msgObject);\n        if (msgObject.file) {\n            msgObject.message = \"\";\n        }\n        \n        return msgObject;\n    }\n}\n\n// Parse time strings\nexport const parseTimeString = (dateStr) => {\n    let dateTimeStr = dateStr.replace(\"a. m.\", \"AM\").replace(\"p. m.\", \"PM\")\n    dateTimeStr = dateTimeStr.replace(\"a.m.\", \"AM\").replace(\"p.m.\", \"PM\")\n    let dateTime = dateTimeStr.split(\" \");\n    const now = new Date();\n    let fmtDate = [[now.getFullYear(), now.getMonth() + 1, now.getDate()].join(\"/\"), dateTime[1]].join(\" \")\n    return new Date(fmtDate);\n}\n\n// Parse messages from lines and create an index\nconst parseAndIndex = (lines, system) => {\n    let index = 0;\n    const result = {};\n    lines.forEach((line) => {\n\n        // Clean unicode from line\n        line = line.replaceAll(/[\\u200E\\u200F\\u202A-\\u202E\\u200B]/g, '');\n\n        const msg = parseMessage(line, system);\n        if (msg) {\n            result[index] = msg;\n            index++;\n        }\n    })\n    return result;\n}\n\n/**\n *\n * @param {string} text\n * @param {string} msgPosition\n * @returns {object} GeoJSON\n */\nexport default function whatsAppParser({ text, msgPosition }) {\n    if (!text) return;\n\n    // Split the full text in lines\n    const lines = text.split(\"\\n\");\n\n    // Initialize the GeoJSON response\n    const geoJSON = {\n        type: \"FeatureCollection\",\n        features: []\n    };\n\n    // A GeoJSON Feature for storing a message\n    let featureObject = {}\n\n    // Detect system (Android, iOS, ...)\n    let system;\n    for (let i = 0; i < lines.length; i++) {\n        system = detectSystem(lines[i]);\n        if (system !== \"UNKNOWN\") {\n            break;\n        }\n    };\n\n    // Get message objects from text lines\n    const messages = parseAndIndex(lines, system);\n    const msgObjects = Object.values(messages);\n\n    // Read each message.\n    // When a location has been found, look for the closest\n    // content from the same user, and attach it to the message.\n    msgObjects.forEach((msgObject, index) => {\n        if (msgObject.message) {\n\n            // Check if there's a location in the message\n            const location = searchLocation(msgObject.message);\n\n            // If there's a location, create a Point.\n            if (location) {\n                featureObject = {\n                    type: \"Feature\",\n                    properties: {},\n                    geometry: {\n                        type: \"Point\",\n                        coordinates: [\n                            parseFloat(location[1]),\n                            parseFloat(location[0])\n                        ]\n                    }\n                }\n                let message;\n                // Look for related content for the Point.\n                switch (msgPosition) {\n                    case \"before\":\n                        message = getClosestPrevMessage(messages, index);\n                        break;\n                    case \"after\":\n                        message = getClosestNextMessage(messages, index);\n                        break;\n                    default:\n                        message = getClosestMessage(messages, index);\n                    break;\n                }\n                // Add the GeoJSON feature\n                featureObject.properties = {...message};\n                geoJSON.features.push(featureObject);\n            }\n        }\n    });\n\n    return geoJSON;\n}\n"],"names":["LOCATION_PATTERN","MSG_PATTERN","detectSystem","line","match_ios","match_android","lookForMediaFile","msgObject","msg","mediaFileIndex","path","searchLocation","match","x","parseMessage","system","username","usernameIndexOf","parseTimeString","dateStr","dateTimeStr","dateTime","now","fmtDate","parseAndIndex","lines","index","result","whatsAppParser","text","msgPosition","geoJSON","featureObject","i","messages","location","message","getClosestPrevMessage","getClosestNextMessage","getClosestMessage"],"mappings":"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"}