import os
import httpx
import logging
import redis.asyncio as redis
import time
import json
from fastapi import FastAPI, HTTPException, Depends
from fastapi.responses import StreamingResponse
from typing import Dict
from models import GeoJson
from io import BytesIO
from fastapi.middleware.cors import CORSMiddleware
from chatmap_py import parser as chatmap_parser
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from db import UserChatMap, Base, engine, SessionLocal
from sqlalchemy.orm import Session

# Logs
logger = logging.getLogger(__name__)
logging.basicConfig(filename='chatmap-api.log', level=logging.INFO)

# Settings

DEBUG = True

# Configure Redis connection
redis_host = os.getenv("REDIS_HOST", "localhost")
redis_port = int(os.getenv("REDIS_PORT", 6379))
redis_client = redis.Redis(host='localhost', port=6379, db=0)

# Redis key for filtering
STREAM_KEY = "wa-messages"
# Expiring time for messages (in minutes)
EXPIRING_MIN = 30
EXPIRING_MIN_MS = EXPIRING_MIN * 60 * 1000

# Linked devices server
server_url = os.getenv("SERVER_URL", "http://localhost:8001")

# API
app = FastAPI()

# Scheduler
scheduler = AsyncIOScheduler()

# Access config
origins = [
    "*",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Dependency to get DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Get QR code
@app.get("/qr", response_class=StreamingResponse)
async def qr(user_id: str):
    async with httpx.AsyncClient() as client:
        response = await client.get(f'{server_url}/start-qr?session={user_id}')
        if response.status_code != 200:
            logger.info(f'Failed to get session: {user_id}')
            raise HTTPException(status_code=502, detail="Failed to get session")

        if "image" not in response.headers.get("Content-Type", ""):
            raise HTTPException(status_code=400, detail="URL did not return an image")

        return StreamingResponse(BytesIO(response.content), media_type="image/png")

# Get Status
@app.get("/status")
async def status(user_id: str) -> Dict[str, str]:
    async with httpx.AsyncClient() as client:
        response = await client.get(f'{server_url}/status?session={user_id}')
        if response.status_code != 200:
            raise HTTPException(status_code=502, detail="Failed to get session")
        return {'status': response.text}

# Get Status
@app.get("/logout")
async def status(user_id: str) -> Dict[str, str]:
    async with httpx.AsyncClient() as client:
        response = await client.get(f'{server_url}/logout?session={user_id}')
        if response.status_code != 200:
            raise HTTPException(status_code=502, detail="Failed to logout")
        return {'status': "logged out"}

# Cleanup old messages
async def cleanup(user_id: str):
    cutoff_time_ms = int(time.time() * 1000) - EXPIRING_MIN_MS
    cutoff_id = f"{cutoff_time_ms}-0"
    entries = await redis_client.xrange(f"{STREAM_KEY}:{user_id}", min='-', max=cutoff_id)
    # Remove data older than (EXPIRING_MIN_MS) minutes
    for entry_id, _ in entries:
        await redis_client.xdel(f"{STREAM_KEY}:{user_id}", entry_id)
    logger.info(f'cleanup: {len(entries)} messages deleted')

# Merge two GeoJSON objects, prevent duplicates
def merge_geojson(currentGeoJSON, newGeoJSON):
    merged = []
    for item in newGeoJSON["features"]:
        merged.append(item)
    for item in currentGeoJSON["features"]:
        if not any(i["properties"]["time"] == item["properties"]["time"] for i in merged):
            merged.append(item)
    return merged

# Get GeoJSON generated by ChatMap
@app.get("/chatmap")
async def get_chatmap(user_id: str, db: Session = Depends(get_db)) -> GeoJson:
    logger.info(f'get_chatmap: session {user_id}')
    try:
        # Get all available messages
        entries = await redis_client.xrange(f"{STREAM_KEY}:{user_id}", min='-', max='+')
        # Cleanup old messages
        await cleanup(user_id)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    data = [
        {bytes.decode(k): bytes.decode(v) if isinstance(v, bytes) else v
        for k, v in entry.items()}
        for entry_id, entry in entries
    ]
    # Get GeoJSON from ChatMap
    geoJSON = chatmap_parser.streamParser(data)

    # Look for existing entries for same user in DB
    userChatmap = db.query(UserChatMap).filter(UserChatMap.id == user_id).first()
    if userChatmap:
        # Merge new GeoJSON with existing one and update DB
        currentGeoJSON = json.loads(userChatmap.geojson)
        if currentGeoJSON:
            mergedGeoJSON = {
                "type": "FeatureCollection",
                "features": merge_geojson(currentGeoJSON, geoJSON)
            }
            userChatmap.geojson = json.dumps(mergedGeoJSON)
            db.commit()
            db.refresh(userChatmap)
            return mergedGeoJSON
    else:
        # Create new entry
        newUserChatmap = UserChatMap(id=user_id, geojson=json.dumps(geoJSON))
        db.add(newUserChatmap)
        db.commit()
        db.refresh(newUserChatmap)
        return geoJSON

# Get all sessions
async def get_sessions():
    sessions = await redis_client.scan(0, match="wa-messages:*", type="stream")
    return [item[0].decode('utf-8').replace("wa-messages:", "") for item in sessions if type(item) != int]

# Update all sessions every (EXPIRING_MIN) minutes
@scheduler.scheduled_job('interval', minutes=EXPIRING_MIN)
async def update():
    sessions = get_sessions()
    for session in sessions:
        await get_chatmap(session)

# On API startup
def on_startup():
    global scheduler
    try:
        Base.metadata.create_all(bind=engine)
        scheduler.start()
    except Exception as e:
        print(f"Error starting scheduler: {e}")

# On API shutdown
def on_shutdown():
    global scheduler
    try:
        scheduler.shutdown(wait=True)
    except Exception as e:
        print(f"Error shutting down scheduler: {e}")

# ----- (FOR DEBUGGING) -----

if DEBUG:
    # Get raw messages
    @app.get("/messages")
    async def get_chatmap(user_id: str):
        try:
            entries = await redis_client.xrange(f"{STREAM_KEY}:{user_id}", min='-', max='+')
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))
        data = [{"id": entry_id, **fields} for entry_id, fields in entries]
        return data
